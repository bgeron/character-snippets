#![warn(rust_2018_idioms)]
#![forbid(unsafe_code)]

use exitfailure::ExitFailure;
use failure::{bail, ensure, Error, ResultExt};
use indexmap::IndexMap;
use serde::{Deserialize, Serialize};
use structopt::StructOpt;

/// Convert a TOML file in a certain format to a Visual Studio Code snippets file.
///
/// This is particularly useful for a file with snippets for Unicode characters.
///
/// The format of the input file should be as follows:
///
///     [Snippets]
///       xbrackets = "〚$1〛"
///       xcheckbox = "☐ "
///       xchecked = "☑ "
///       xcheckmark = "✓"
///       xch = "✓"
///
/// Visual Studio Code will interpret variables such as $1 as placeholders.
///
/// Output will be sent to standard output.
#[derive(Debug, StructOpt)]
#[structopt(verbatim_doc_comment)]
struct Cli {
    /// Skip printing a header with the current date and time
    #[structopt(long)]
    no_header: bool,

    /// Use a builtin snippets definition, instead of a custom file
    #[structopt(long)]
    builtin: bool,

    /// The path to the file to read
    #[structopt(parse(from_os_str))]
    path: Option<std::path::PathBuf>,
}

impl Cli {
    #[cfg(test)]
    fn builtin_for_test() -> Self {
        Cli {
            no_header: true,
            builtin: true,
            path: None,
        }
    }
}

#[derive(Deserialize)]
struct Toml {
    #[serde(rename = "Snippets")]
    snippets: Snippets,
}

type Snippets = IndexMap<String, String>;

struct Snippet {
    name: String,
    value: String,
}

type VsCode = IndexMap<String, VsCodeDetails>;

#[derive(Serialize)]
struct VsCodeDetails {
    prefix: String,
    body: Vec<String>,
}

fn parse_toml(toml: toml::Value) -> Result<Vec<Snippet>, Error> {
    let map = toml
        .try_into::<Toml>()
        .with_context(|_| "unexpected structure in TOML")?
        .snippets;

    Ok(map
        .into_iter()
        .map(|(name, value)| Snippet { name, value })
        .collect::<Vec<Snippet>>())
}

fn gen_vscode_item(snippet: &Snippet) -> (String, VsCodeDetails) {
    (
        format!("Character: {}", snippet.name),
        VsCodeDetails {
            prefix: snippet.name.clone(),
            body: vec![snippet.value.clone()],
        },
    )
}

fn gen_vscode(
    snippets: &[Snippet],
    write_header: bool,
    mut writer: impl std::io::Write,
) -> Result<(), Error> {
    let data = snippets.iter().map(gen_vscode_item).collect::<VsCode>();

    if write_header {
        write!(
            &mut writer,
            "\
            // Visual Studio Code snippets file generated by github/bgeron/character-snippets .\n\
            //\n\
            // Generated on {}. Contains {} snippets.\n\n",
            chrono::Local::now(),
            data.len()
        )?;
    }

    serde_json::to_writer_pretty(&mut writer, &data)?;
    writeln!(&mut writer)?;
    Ok(())
}

const BUILTIN_SNIPPETS: &str = include_str!("builtin-snippets.toml");

fn main() -> Result<(), ExitFailure> {
    let args = Cli::from_args();

    let in_toml_str: String = toml_str_from_args(&args)?;

    let in_toml = toml::from_str(&in_toml_str).with_context(|_| "could not parse TOML")?;

    let snippets = parse_toml(in_toml)?;

    let write_header = !args.no_header;

    gen_vscode(&snippets, write_header, &mut std::io::stdout().lock())?;

    Ok(())
}

fn toml_str_from_args(args: &Cli) -> Result<String, failure::Error> {
    if let Some(path) = &args.path {
        ensure!(
            !args.builtin,
            "cannot use both the builtin snippets and a custom file"
        );

        Ok(std::fs::read_to_string(&path)
            .with_context(|_| format!("could not read input file `{}`", &path.display()))?)
    } else if args.builtin {
        Ok(BUILTIN_SNIPPETS.to_string())
    } else {
        bail!("Please provide either --builtin or a custom file.\n\nRun with --help to see usage.")
    }
}

#[cfg(test)]
mod test {
    use super::*;
    #[test]
    fn builtin_toml_output() {
        let in_toml_str = toml_str_from_args(&Cli::builtin_for_test()).unwrap();
        let in_toml = toml::from_str(&in_toml_str).unwrap();
        let mut buf : Vec<u8> = Vec::new();
        gen_vscode(&*parse_toml(in_toml).unwrap(), false, &mut buf).unwrap();
        assert_eq!(blake3::hash(&*buf).to_hex().as_str(), "3e7ef23772f36408e071bcdb385a977e2c22536e85ccd52cb9909ab1617fa3f5");
    }
}
